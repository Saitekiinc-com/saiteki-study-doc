# Lv.1 基礎: Webアプリケーションの仕組みと原理原則

Lv.1のゴールは、<strong>「特定の技術（How）ではなく、システム全体を貫く設計思想（Why/Philosophy）を理解すること」</strong>です。
ReactやAWSといった技術は時代とともに変わりますが、その根底にある「原理原則」は変わりません。フルスタックエンジニアとして、あらゆる技術選定の判断基準となるメンタルモデルを構築します。

## 1. Web標準とHTTP (The Infrastructure)
なぜWebはこれほどまでにスケールし、世界中のシステムを繋ぐことができたのか？その設計思想を学びます。

### 学習項目
*   **Statelessness (ステートレス)**:
    *   「サーバーはクライアントの状態を覚えない」という制約。
    *   なぜこれがスケーラビリティ（サーバーを何台でも増やせること）に直結するのか。
*   **Resource Orientation (リソース指向)**:
    *   「操作（動詞）」ではなく「リソース（名詞）」でシステムを捉える思考法。
    *   URLは「場所」ではなく「モノ」を指すべきである理由。
*   **Idempotency (冪等性)**:
    *   「同じリクエストを何度送っても結果が変わらない」という性質。
    *   ネットワークが不安定な環境で、安全にリトライ処理を行うための必須概念。

### チェックリスト
- [ ] 「ステートレスな設計」が、サーバーの負荷分散にどう役立つか説明できる。
- [ ] 冪等性が担保されていないAPIでリトライを行った場合のリスク（二重決済など）を説明できる。

### 📚 推奨リソース
*   **書籍**: [Webを支える技術](https://gihyo.jp/book/2010/978-4-7741-4204-3)
    *   Webの聖書。HTTPの歴史からRESTの設計思想までを網羅した必読書。

## 2. 非同期と型システム (The Language)
JavaScript/TypeScriptという言語を通じて、現代のプログラミングに必須の「並行処理」と「契約」の概念を学びます。

### 学習項目
*   **Event Loop & Non-blocking (非同期の哲学)**:
    *   たった1つのスレッドで、数千の同時リクエストを捌く仕組み。
    *   「待ち時間（I/O）」を有効活用し、CPUを止めないという思想。
*   **Type System as a Contract (契約としての型)**:
    *   型は単なるエラーチェックではない。コンポーネント間の「契約書」である。
    *   「Any型」を使うことが、なぜ「契約違反（信頼の放棄）」になるのか。

### チェックリスト
- [ ] 「ブロッキング処理」がなぜWebサーバーにとって致命的なのか説明できる。
- [ ] 型定義を見るだけで、その関数の「責務」と「使い方」を理解できるコードを書ける。

### 📚 推奨リソース
*   **書籍**: [JavaScript Primer 迷わないための入門書](https://jsprimer.net/)
    *   ES2015以降をベースにした現代的な入門書。「非同期処理」の章で、イベントループやPromiseの仕組みが丁寧に解説されています。
*   **書籍**: [プロを目指す人のためのTypeScript入門](https://gihyo.jp/book/2022/978-4-297-12747-3)
    *   通称「ブルーベリー本」。型システムを「安全なコードを書くための契約」として学べる良書。

## 3. フロントエンドのメンタルモデル (The UI)
UIライブラリの流行り廃りを超えて、GUIアプリケーション構築の普遍的な原則を学びます。

### 学習項目
*   **Declarative vs Imperative (宣言的 vs 命令的)**:
    *   「どう更新するか（手順）」ではなく「あるべき状態は何か（結果）」を定義する。
    *   手順の複雑さから解放され、バグを減らすためのパラダイムシフト。
*   **Single Source of Truth (信頼できる唯一の情報源)**:
    *   「データは一箇所にしか存在させない」という鉄則。
    *   状態のコピーを持った瞬間に、同期ズレというバグが生まれる理由。

### チェックリスト
- [ ] 「命令的」なコードと「宣言的」なコードの違いを、具体的な例（DOM操作など）で説明できる。
- [ ] 画面上のデータと、裏側のデータが食い違うバグの原因を「Single Source of Truth」の観点で特定できる。

### 📚 推奨リソース
*   **公式ドキュメント**: [Thinking in React (Reactの流儀)](https://ja.react.dev/learn/thinking-in-react)
    *   「宣言的UI」と「Single Source of Truth」の考え方を、最も簡潔に学べる公式ガイド。

## 4. コンポーネント設計 (The Architecture)
UIをメンテナンス可能な部品に分割するための設計論です。
Atomic Designなどの特定のメソドロジーに従うかどうかに関わらず、以下の「設計の思想」を押さえておくことが重要です。

### 学習項目
*   **関心の分離 (Separation of Concerns)**:
    *   **Presentational Component**: 「どう見えるか」だけを担当（Propsを受け取って描画）。
    *   **Container Component**: 「どう動くか」を担当（データを取得してPropsで渡す）。
    *   これらを分けることで、デザイン変更の影響をロジックに波及させないようにします。
*   **単一責任の原則 (Single Responsibility Principle)**:
    *   1つのコンポーネントは「1つのこと」だけをする。
    *   「ユーザー一覧を表示し、かつ、ユーザー登録もする」ような巨大なコンポーネントは分割する。
*   **依存の方向性**:
    *   特定のページでしか使えないコンポーネント（具体的）と、どこでも使えるボタン（抽象的）を区別する。
    *   抽象的なコンポーネントが、具体的なコンポーネントに依存しないようにする。

### チェックリスト
- [ ] ロジックを含むコンポーネントと、見た目だけのコンポーネントを分離して実装できる。
- [ ] 「このコンポーネントの役割は何か？」と聞かれたときに、一言で答えられる。

### 📚 推奨リソース
*   **書籍**: [良いコード/悪いコードで学ぶ設計入門](https://gihyo.jp/book/2022/978-4-297-12783-1)
    *   「責務の分離」や「依存関係」について、具体的なコード例（悪い例→良い例）で学べる実践的な入門書。

- [ ] 「このコンポーネントの役割は何か？」と聞かれたときに、一言で答えられる。

## 5. ビジネスロジックとドメインモデリング (The Core)
UIやDBは「詳細」であり、システムの「核」ではありません。
ビジネスルールをどのように守り、表現するかという設計思想を学びます。

### 学習項目
*   **Encapsulation (カプセル化)**:
    *   データと、それを操作する振る舞いをセットにする。
    *   「不正な状態」を作らせないために、内部データを隠蔽し、安全な操作のみを公開する（ガードする）。
*   **Pure Functions (純粋関数)**:
    *   「入力が同じなら、必ず出力も同じになる」関数。
    *   DBアクセスやグローバル変数への依存（副作用）を排除することで、テストが劇的に簡単になる理由。
*   **Separation of Logic and I/O (ロジックとI/Oの分離)**:
    *   「計算（消費税の計算など）」と「通信（DB保存など）」を混ぜない。
    *   ビジネスロジックが、DBやWebフレームワークの都合に依存しないようにする（ヘキサゴナルアーキテクチャの基礎）。

### チェックリスト
- [ ] 「副作用のある関数」と「純粋関数」を見分けられる。
- [ ] ビジネスロジックの中に、SQLやHTTPリクエストが混ざっていない状態を作れる。

### 📚 推奨リソース
*   **書籍**: [ドメイン駆動設計入門](https://www.shoeisha.co.jp/book/detail/9784798150727)
    *   「ドメイン（ビジネスルール）」をコードでどう表現するか、ボトムアップで学べるDDDの入門書。

## 6. バックエンドとデータベース (The Data)
データを守り、正しく届けるためのトレードオフと契約について学びます。

### 学習項目
*   **ACID vs CAP Theorem (整合性と可用性のトレードオフ)**:
    *   「絶対にデータを失わない（整合性）」ことと「いつでも使える（可用性）」ことは、分散システムでは両立しない場合がある。
    *   銀行システムとSNSの「いいね」で、選ぶべきDBが異なる理由。
*   **API as a Contract (契約としてのAPI)**:
    *   APIは、バックエンドがフロントエンドに対して提供する「サービス保証」。
    *   一度公開したAPIを変更することが、なぜ「契約違反（Breaking Change）」として扱われるのか。

### チェックリスト
- [ ] 自分の作ろうとしているサービスが、整合性重視（ACID）か可用性重視（CAPのAP）か判断できる。
- [ ] APIのレスポンス構造を変更する際、クライアントにどのような影響が出るか予測できる。

### 📚 推奨リソース
*   **書籍**: [データ指向アプリケーションデザイン](https://www.oreilly.co.jp/books/9784873118703/)
    *   分散システムのバイブル。ACID、CAP定理、レプリケーションなど、データを扱うシステムの「原理原則」が詰まっています。

